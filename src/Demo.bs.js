// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as List from "rescript/lib/es6/list.js";
import * as Process from "process";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

var is_linux = "linux" === Process.platform;

function findIndex(list, item) {
  var _list = list;
  var _index = 0;
  while(true) {
    var index = _index;
    var list$1 = _list;
    if (list$1) {
      if (list$1.hd === item) {
        return index;
      }
      _index = index + 1 | 0;
      _list = list$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function to_little_endian_32(i) {
  var b1 = i & 255;
  var b2 = (i >>> 8) & 255;
  var b3 = (i >>> 16) & 255;
  var b4 = (i >>> 24) & 255;
  return {
          hd: b1,
          tl: {
            hd: b2,
            tl: {
              hd: b3,
              tl: {
                hd: b4,
                tl: /* [] */0
              }
            }
          }
        };
}

function vadd(a, b) {
  if (a.TAG === /* Vint */0) {
    if (b.TAG === /* Vint */0) {
      return {
              TAG: /* Vint */0,
              _0: a._0 + b._0 | 0
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            43,
            11
          ],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Demo.res",
          43,
          11
        ],
        Error: new Error()
      };
}

function vmul(a, b) {
  if (a.TAG === /* Vint */0) {
    if (b.TAG === /* Vint */0) {
      return {
              TAG: /* Vint */0,
              _0: Math.imul(a._0, b._0)
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            50,
            11
          ],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Demo.res",
          50,
          11
        ],
        Error: new Error()
      };
}

var Ast = {
  vadd: vadd,
  vmul: vmul
};

var last_type_id = {
  contents: 0
};

function to_ident_string(id) {
  var match = id.ty;
  var tmp;
  switch (match) {
    case /* Branch */0 :
        tmp = "branch";
        break;
    case /* Function */1 :
        tmp = "fn";
        break;
    case /* Var */2 :
        tmp = "var";
        break;
    
  }
  return id.name + "/" + tmp;
}

function new_type(param) {
  last_type_id.contents = last_type_id.contents + 1 | 0;
  return {
          TAG: /* TVar */0,
          _0: String(last_type_id.contents)
        };
}

function to_type_string(typ) {
  if (typeof typ === "number") {
    if (typ === /* TInt */0) {
      return "Int";
    } else {
      return "Bool";
    }
  } else if (typ.TAG === /* TVar */0) {
    return "T" + typ._0 + "";
  } else {
    return Belt_List.reduce(typ._0, "", (function (s, typ) {
                  return s + to_type_string(typ) + ",";
                })) + "->" + to_type_string(typ._1);
  }
}

function dump_env(ctx) {
  for(var i = 0 ,i_finish = Belt_List.length(ctx); i < i_finish; ++i){
    var match = List.nth(ctx, i);
    var typ_name = to_type_string(match[1]);
    console.log(match[0].name + " = " + typ_name);
  }
}

function dump_constraints(cs) {
  for(var i = 0 ,i_finish = Belt_List.length(cs); i < i_finish; ++i){
    var match = List.nth(cs, i);
    var key = to_type_string(match[0]);
    var value = to_type_string(match[1]);
    console.log(key + " = " + value);
  }
}

function check_expr(ctx, expr) {
  switch (expr.TAG | 0) {
    case /* CstI */0 :
        return [
                /* TInt */0,
                /* [] */0
              ];
    case /* CstB */1 :
        return [
                /* TBool */1,
                /* [] */0
              ];
    case /* Var */5 :
        var name = expr._0;
        var match = List.find((function (param) {
                return param[0].stamp === name.stamp;
              }), ctx);
        return [
                match[1],
                /* [] */0
              ];
    case /* Let */6 :
        var match$1 = check_expr(ctx, expr._1);
        var ctx_0 = [
          expr._0,
          match$1[0]
        ];
        var ctx$1 = {
          hd: ctx_0,
          tl: ctx
        };
        var match$2 = check_expr(ctx$1, expr._2);
        return [
                match$2[0],
                Belt_List.concatMany([
                      match$1[1],
                      match$2[1]
                    ])
              ];
    case /* Fn */7 :
        var params = expr._0;
        var param_types = Belt_List.map(params, (function (param) {
                return new_type(undefined);
              }));
        var ctx$2 = Belt_List.concatMany([
              Belt_List.zip(params, param_types),
              ctx
            ]);
        var match$3 = check_expr(ctx$2, expr._1);
        return [
                {
                  TAG: /* TFun */1,
                  _0: param_types,
                  _1: match$3[0]
                },
                match$3[1]
              ];
    case /* App */8 :
        var id = expr._0;
        var t = new_type(undefined);
        var match$4 = List.find((function (param) {
                return param[0].stamp === id.stamp;
              }), ctx);
        var match$5 = Belt_List.unzip(Belt_List.map(expr._1, (function (i) {
                    return check_expr(ctx, i);
                  })));
        var c_0 = match$4[1];
        var c_1 = {
          TAG: /* TFun */1,
          _0: match$5[0],
          _1: t
        };
        var c = [
          c_0,
          c_1
        ];
        console.log("==> app: " + to_type_string(t));
        dump_constraints({
              hd: c,
              tl: /* [] */0
            });
        return [
                t,
                {
                  hd: c,
                  tl: List.concat(match$5[1])
                }
              ];
    case /* Le */9 :
        var match$6 = check_expr(ctx, expr._0);
        var match$7 = check_expr(ctx, expr._1);
        return [
                /* TBool */1,
                Belt_List.concatMany([
                      {
                        hd: [
                          match$6[0],
                          /* TInt */0
                        ],
                        tl: {
                          hd: [
                            match$7[0],
                            /* TInt */0
                          ],
                          tl: match$6[1]
                        }
                      },
                      match$7[1]
                    ])
              ];
    case /* If */10 :
        var t$1 = new_type(undefined);
        var match$8 = check_expr(ctx, expr._0);
        var match$9 = check_expr(ctx, expr._1);
        var match$10 = check_expr(ctx, expr._2);
        var c_0$1 = [
          match$8[0],
          /* TBool */1
        ];
        var c_1$1 = {
          hd: [
            match$9[0],
            t$1
          ],
          tl: {
            hd: [
              match$10[0],
              t$1
            ],
            tl: /* [] */0
          }
        };
        var c$1 = {
          hd: c_0$1,
          tl: c_1$1
        };
        console.log("==> if: " + to_type_string(t$1));
        dump_constraints(c$1);
        return [
                t$1,
                Belt_List.concatMany([
                      c$1,
                      match$8[1],
                      match$9[1],
                      match$10[1]
                    ])
              ];
    default:
      var match$11 = check_expr(ctx, expr._0);
      var match$12 = check_expr(ctx, expr._1);
      return [
              /* TInt */0,
              Belt_List.concatMany([
                    {
                      hd: [
                        match$11[0],
                        /* TInt */0
                      ],
                      tl: {
                        hd: [
                          match$12[0],
                          /* TInt */0
                        ],
                        tl: match$11[1]
                      }
                    },
                    match$12[1]
                  ])
            ];
  }
}

function occurs(typevar, typ) {
  if (typeof typ === "number") {
    return false;
  } else if (typ.TAG === /* TVar */0) {
    return typ._0 === typevar;
  } else if (occurs(typevar, typ._1)) {
    return true;
  } else {
    return Belt_List.some(typ._0, (function (t) {
                  return occurs(typevar, t);
                }));
  }
}

function replace_type(typevar, typ, cs) {
  var replace = function (typevar, typ, to_typ) {
    if (typeof typ === "number") {
      return typ;
    }
    if (typ.TAG === /* TVar */0) {
      if (typ._0 === typevar) {
        return to_typ;
      } else {
        return typ;
      }
    }
    var arg_types = Belt_List.map(typ._0, (function (t) {
            return replace(typevar, t, to_typ);
          }));
    var ret_type = replace(typevar, typ._1, to_typ);
    return {
            TAG: /* TFun */1,
            _0: arg_types,
            _1: ret_type
          };
  };
  return Belt_List.map(cs, (function (param) {
                return [
                        replace(typevar, param[0], typ),
                        replace(typevar, param[1], typ)
                      ];
              }));
}

function dump_subst(subst) {
  console.log("==> subst");
  for(var i = 0 ,i_finish = Belt_List.length(subst); i < i_finish; ++i){
    var match = List.nth(subst, i);
    console.log("    T" + match[0] + " -> " + to_type_string(match[1]));
  }
}

function solve(cs) {
  var go = function (_cs, _s) {
    while(true) {
      var s = _s;
      var cs = _cs;
      if (!cs) {
        return s;
      }
      var rest = cs.tl;
      var c = cs.hd;
      var x;
      var t;
      var x$1 = c[0];
      var exit = 0;
      if (typeof x$1 === "number") {
        if (x$1 === /* TInt */0) {
          if (c[1] === 0) {
            _cs = rest;
            continue ;
          }
          exit = 2;
        } else {
          var match = c[1];
          if (typeof match === "number") {
            if (match !== 0) {
              _cs = rest;
              continue ;
            }
            exit = 2;
          } else {
            exit = 2;
          }
        }
      } else if (x$1.TAG === /* TVar */0) {
        x = x$1._0;
        t = c[1];
      } else {
        var match$1 = c[1];
        if (typeof match$1 === "number") {
          exit = 2;
        } else {
          if (match$1.TAG === /* TFun */1) {
            var param_types = Belt_List.zip(x$1._0, match$1._0);
            _cs = Belt_List.concatMany([
                  param_types,
                  {
                    hd: [
                      x$1._1,
                      match$1._1
                    ],
                    tl: rest
                  }
                ]);
            continue ;
          }
          exit = 2;
        }
      }
      if (exit === 2) {
        var x$2 = c[1];
        var exit$1 = 0;
        if (typeof x$2 === "number" || x$2.TAG !== /* TVar */0) {
          exit$1 = 3;
        } else {
          x = x$2._0;
          t = x$1;
        }
        if (exit$1 === 3) {
          return Pervasives.failwith("Expected type <" + to_type_string(x$2) + ">, but got <" + to_type_string(x$1) + ">");
        }
        
      }
      if (occurs(x, t)) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Demo.res",
                265,
                12
              ],
              Error: new Error()
            };
      }
      _s = {
        hd: [
          x,
          t
        ],
        tl: s
      };
      _cs = replace_type(x, t, rest);
      continue ;
    };
  };
  var subst = go(cs, /* [] */0);
  dump_subst(subst);
  return subst;
}

var last_id = {
  contents: 0
};

function new_var_ident(name) {
  last_id.contents = last_id.contents + 1 | 0;
  return {
          name: name,
          stamp: last_id.contents,
          ty: /* Var */2
        };
}

function new_branch_ident(name) {
  last_id.contents = last_id.contents + 1 | 0;
  return {
          name: name,
          stamp: last_id.contents,
          ty: /* Branch */0
        };
}

function new_fn_ident(name) {
  last_id.contents = last_id.contents + 1 | 0;
  return {
          name: name,
          stamp: last_id.contents,
          ty: /* Function */1
        };
}

function compile(expr) {
  var compile_inner = function (expr, env) {
    switch (expr.TAG | 0) {
      case /* CstI */0 :
          return {
                  TAG: /* CstI */0,
                  _0: expr._0
                };
      case /* CstB */1 :
          return {
                  TAG: /* CstB */1,
                  _0: expr._0
                };
      case /* Add */2 :
          return {
                  TAG: /* Add */2,
                  _0: compile_inner(expr._0, env),
                  _1: compile_inner(expr._1, env)
                };
      case /* Sub */3 :
          return {
                  TAG: /* Sub */3,
                  _0: compile_inner(expr._0, env),
                  _1: compile_inner(expr._1, env)
                };
      case /* Mul */4 :
          return {
                  TAG: /* Mul */4,
                  _0: compile_inner(expr._0, env),
                  _1: compile_inner(expr._1, env)
                };
      case /* Var */5 :
          return {
                  TAG: /* Var */5,
                  _0: List.assoc(expr._0, env)
                };
      case /* Let */6 :
          var e1 = expr._1;
          var name = expr._0;
          var ident;
          ident = e1.TAG === /* Fn */7 ? new_fn_ident(name) : new_var_ident(name);
          var env_0 = [
            name,
            ident
          ];
          var env$1 = {
            hd: env_0,
            tl: env
          };
          return {
                  TAG: /* Let */6,
                  _0: ident,
                  _1: compile_inner(e1, env$1),
                  _2: compile_inner(expr._2, env$1)
                };
      case /* Fn */7 :
          var params = expr._0;
          var idents = Belt_List.map(params, new_var_ident);
          var mapping = Belt_List.zip(params, idents);
          return {
                  TAG: /* Fn */7,
                  _0: idents,
                  _1: compile_inner(expr._1, Belt_List.concatMany([
                            mapping,
                            env
                          ]))
                };
      case /* App */8 :
          return {
                  TAG: /* App */8,
                  _0: List.assoc(expr._0, env),
                  _1: Belt_List.map(expr._1, (function (item) {
                          return compile_inner(item, env);
                        }))
                };
      case /* Le */9 :
          return {
                  TAG: /* Le */9,
                  _0: compile_inner(expr._0, env),
                  _1: compile_inner(expr._1, env)
                };
      case /* If */10 :
          return {
                  TAG: /* If */10,
                  _0: compile_inner(expr._0, env),
                  _1: compile_inner(expr._1, env),
                  _2: compile_inner(expr._2, env)
                };
      
    }
  };
  return compile_inner(expr, /* [] */0);
}

var Resolve = {
  last_type_id: last_type_id,
  to_ident_string: to_ident_string,
  new_type: new_type,
  to_type_string: to_type_string,
  dump_env: dump_env,
  dump_constraints: dump_constraints,
  check_expr: check_expr,
  occurs: occurs,
  replace_type: replace_type,
  dump_subst: dump_subst,
  solve: solve,
  last_id: last_id,
  new_var_ident: new_var_ident,
  new_branch_ident: new_branch_ident,
  new_fn_ident: new_fn_ident,
  compile: compile
};

function print(expr) {
  var go = function (expr) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return String(expr._0);
      case /* Add */1 :
          return "(" + go(expr._0) + ") + (" + go(expr._1) + ")";
      case /* Mul */2 :
          return "(" + go(expr._0) + ") * (" + go(expr._1) + ")";
      case /* Var */3 :
          return "var" + String(expr._0);
      case /* Let */4 :
          return "let v0 = (" + go(expr._0) + ") in (" + go(expr._1) + ")";
      case /* Fn */5 :
          return "fn(" + go(expr._1) + ")";
      case /* App */6 :
          return "app( " + go(expr._0) + Belt_List.reduce(Belt_List.map(expr._1, go), "", (function (list, item) {
                        return list + ", (" + item + "), ";
                      })) + " )";
      
    }
  };
  return go(expr);
}

var Nameless = {
  print: print
};

function find_local_index(env, local_index) {
  var _env = env;
  var _local_index = local_index;
  var _stack_index = 0;
  while(true) {
    var stack_index = _stack_index;
    var local_index$1 = _local_index;
    var env$1 = _env;
    if (env$1) {
      if (env$1.hd) {
        _stack_index = stack_index + 1 | 0;
        _env = env$1.tl;
        continue ;
      }
      if (local_index$1 === 0) {
        return stack_index;
      }
      _stack_index = stack_index + 1 | 0;
      _local_index = local_index$1 - 1 | 0;
      _env = env$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function compile$1(expr) {
  var go = function (expr, env) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  TAG: /* Cst */0,
                  _0: expr._0
                };
      case /* Add */1 :
          return {
                  TAG: /* Add */1,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Stmp */1,
                        tl: env
                      })
                };
      case /* Mul */2 :
          return {
                  TAG: /* Mul */2,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Stmp */1,
                        tl: env
                      })
                };
      case /* Var */3 :
          return {
                  TAG: /* Var */3,
                  _0: find_local_index(env, expr._0)
                };
      case /* Let */4 :
          return {
                  TAG: /* Let */4,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Slocal */0,
                        tl: env
                      })
                };
      case /* Fn */5 :
          return {
                  TAG: /* Fn */5,
                  _0: go(expr._1, Belt_List.concatMany([
                            Belt_List.makeBy(expr._0, (function (param) {
                                    return /* Slocal */0;
                                  })),
                            env
                          ]))
                };
      case /* App */6 :
          return {
                  TAG: /* App */6,
                  _0: go(expr._0, env),
                  _1: Belt_List.map(expr._1, (function (item) {
                          return go(item, env);
                        }))
                };
      
    }
  };
  return go(expr, /* [] */0);
}

function print$1(expr) {
  var go = function (expr) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return String(expr._0);
      case /* Add */1 :
          return "(" + go(expr._0) + ") + (" + go(expr._1) + ")";
      case /* Mul */2 :
          return "(" + go(expr._0) + ") * (" + go(expr._1) + ")";
      case /* Var */3 :
          return "var" + String(expr._0);
      case /* Let */4 :
          return "let v0 = (" + go(expr._0) + ") in (" + go(expr._1) + ")";
      case /* Fn */5 :
          return "fn(" + go(expr._0) + ")";
      case /* App */6 :
          return "app( " + go(expr._0) + ", " + Belt_List.reduce(Belt_List.map(expr._1, go), "", (function (list, item) {
                        return list + "(" + item + "), ";
                      })) + " )";
      
    }
  };
  return go(expr);
}

var Indexed = {
  find_local_index: find_local_index,
  compile: compile$1,
  print: print$1
};

var ident_main = new_fn_ident("main");

function find_local_index$1(env, name) {
  var _env = env;
  var _stack_index = 0;
  while(true) {
    var stack_index = _stack_index;
    var env$1 = _env;
    if (env$1) {
      var head = env$1.hd;
      if (head) {
        var head$1 = head._0;
        if (head$1.stamp === name.stamp && head$1.ty === name.ty) {
          return stack_index;
        }
        _stack_index = stack_index + 1 | 0;
        _env = env$1.tl;
        continue ;
      }
      _stack_index = stack_index + 1 | 0;
      _env = env$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function preprocess(expr) {
  var preprocess_rec = function (expr) {
    switch (expr.TAG | 0) {
      case /* CstI */0 :
          return [
                  {
                    TAG: /* CstI */0,
                    _0: expr._0
                  },
                  /* [] */0
                ];
      case /* CstB */1 :
          return [
                  {
                    TAG: /* CstB */1,
                    _0: expr._0
                  },
                  /* [] */0
                ];
      case /* Add */2 :
          var match = preprocess_rec(expr._0);
          var match$1 = preprocess_rec(expr._1);
          return [
                  {
                    TAG: /* Add */2,
                    _0: match[0],
                    _1: match$1[0]
                  },
                  Belt_List.concatMany([
                        match[1],
                        match$1[1]
                      ])
                ];
      case /* Sub */3 :
          var match$2 = preprocess_rec(expr._0);
          var match$3 = preprocess_rec(expr._1);
          return [
                  {
                    TAG: /* Sub */3,
                    _0: match$2[0],
                    _1: match$3[0]
                  },
                  Belt_List.concatMany([
                        match$2[1],
                        match$3[1]
                      ])
                ];
      case /* Mul */4 :
          var match$4 = preprocess_rec(expr._0);
          var match$5 = preprocess_rec(expr._1);
          return [
                  {
                    TAG: /* Mul */4,
                    _0: match$4[0],
                    _1: match$5[0]
                  },
                  Belt_List.concatMany([
                        match$4[1],
                        match$5[1]
                      ])
                ];
      case /* Var */5 :
          return [
                  {
                    TAG: /* Var */5,
                    _0: expr._0
                  },
                  /* [] */0
                ];
      case /* Let */6 :
          var v1 = expr._1;
          var binding = expr._0;
          if (v1.TAG === /* Fn */7) {
            var match$6 = preprocess_rec(expr._2);
            var match$7 = preprocess_rec(v1._1);
            return [
                    match$6[0],
                    Belt_List.concatMany([
                          {
                            hd: [
                              binding,
                              v1._0,
                              match$7[0]
                            ],
                            tl: match$7[1]
                          },
                          match$6[1]
                        ])
                  ];
          }
          var match$8 = preprocess_rec(v1);
          var match$9 = preprocess_rec(expr._2);
          return [
                  {
                    TAG: /* Let */6,
                    _0: binding,
                    _1: match$8[0],
                    _2: match$9[0]
                  },
                  Belt_List.concatMany([
                        match$8[1],
                        match$9[1]
                      ])
                ];
      case /* Fn */7 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Demo.res",
                  544,
                  20
                ],
                Error: new Error()
              };
      case /* App */8 :
          var match$10 = Belt_List.reduce(expr._1, [
                /* [] */0,
                /* [] */0
              ], (function (param, arg) {
                  var match = preprocess_rec(arg);
                  return [
                          {
                            hd: match[0],
                            tl: param[0]
                          },
                          Belt_List.concatMany([
                                match[1],
                                param[1]
                              ])
                        ];
                }));
          return [
                  {
                    TAG: /* App */7,
                    _0: expr._0,
                    _1: match$10[0]
                  },
                  match$10[1]
                ];
      case /* Le */9 :
          var match$11 = preprocess_rec(expr._0);
          var match$12 = preprocess_rec(expr._1);
          return [
                  {
                    TAG: /* Le */8,
                    _0: match$11[0],
                    _1: match$12[0]
                  },
                  Belt_List.concatMany([
                        match$11[1],
                        match$12[1]
                      ])
                ];
      case /* If */10 :
          var match$13 = preprocess_rec(expr._0);
          var match$14 = preprocess_rec(expr._1);
          var match$15 = preprocess_rec(expr._2);
          return [
                  {
                    TAG: /* If */9,
                    _0: match$13[0],
                    _1: match$14[0],
                    _2: match$15[0]
                  },
                  Belt_List.concatMany([
                        match$13[1],
                        match$14[1],
                        match$15[1]
                      ])
                ];
      
    }
  };
  var match = preprocess_rec(expr);
  return {
          hd: [
            ident_main,
            /* [] */0,
            match[0]
          ],
          tl: match[1]
        };
}

function compile_expr(expr, env) {
  var compile_inner = function (expr, env, if_label) {
    switch (expr.TAG | 0) {
      case /* CstI */0 :
          return {
                  hd: {
                    TAG: /* Cst */0,
                    _0: expr._0
                  },
                  tl: /* [] */0
                };
      case /* CstB */1 :
          return Pervasives.failwith("TODO");
      case /* Add */2 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env, if_label + 1 | 0),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }, if_label + 2 | 0),
                      {
                        hd: /* Add */0,
                        tl: /* [] */0
                      }
                    ]);
      case /* Sub */3 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env, if_label + 1 | 0),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }, if_label + 2 | 0),
                      {
                        hd: /* Sub */1,
                        tl: /* [] */0
                      }
                    ]);
      case /* Mul */4 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env, if_label + 1 | 0),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }, if_label + 2 | 0),
                      {
                        hd: /* Mul */2,
                        tl: /* [] */0
                      }
                    ]);
      case /* Var */5 :
          return {
                  hd: {
                    TAG: /* Var */1,
                    _0: find_local_index$1(env, expr._0)
                  },
                  tl: /* [] */0
                };
      case /* Let */6 :
          return Belt_List.concatMany([
                      compile_inner(expr._1, env, if_label + 1 | 0),
                      compile_inner(expr._2, {
                            hd: /* Slocal */{
                              _0: expr._0
                            },
                            tl: env
                          }, if_label + 2 | 0),
                      {
                        hd: /* Swap */4,
                        tl: {
                          hd: /* Pop */3,
                          tl: /* [] */0
                        }
                      }
                    ]);
      case /* App */7 :
          var args = expr._1;
          var match = Belt_List.reduceWithIndex(args, [
                /* [] */0,
                env
              ], (function (param, arg, i) {
                  var env = param[1];
                  return [
                          Belt_List.concatMany([
                                param[0],
                                compile_inner(arg, env, (if_label + 1 | 0) + i | 0)
                              ]),
                          {
                            hd: /* Stmp */0,
                            tl: env
                          }
                        ];
                }));
          return Belt_List.concatMany([
                      match[0],
                      {
                        hd: {
                          TAG: /* Call */2,
                          _0: expr._0,
                          _1: Belt_List.length(args)
                        },
                        tl: /* [] */0
                      }
                    ]);
      case /* Le */8 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env, if_label + 1 | 0),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }, if_label + 2 | 0),
                      {
                        hd: /* Le */5,
                        tl: /* [] */0
                      }
                    ]);
      case /* If */9 :
          var false_label = new_branch_ident("false");
          var end_of_if = new_branch_ident("end_of_if");
          return Belt_List.concatMany([
                      compile_inner(expr._0, env, if_label + 1 | 0),
                      {
                        hd: {
                          TAG: /* IfZero */4,
                          _0: false_label
                        },
                        tl: compile_inner(expr._1, env, if_label + 2 | 0)
                      },
                      {
                        hd: {
                          TAG: /* Goto */5,
                          _0: end_of_if
                        },
                        tl: {
                          hd: {
                            TAG: /* Label */6,
                            _0: false_label
                          },
                          tl: compile_inner(expr._2, env, if_label + 3 | 0)
                        }
                      },
                      {
                        hd: {
                          TAG: /* Label */6,
                          _0: end_of_if
                        },
                        tl: /* [] */0
                      }
                    ]);
      
    }
  };
  return compile_inner(expr, env, 0);
}

function compile_fun(fun) {
  var params = fun[1];
  var stack = Belt_List.reverse(Belt_List.map(params, (function (name) {
              return /* Slocal */{
                      _0: name
                    };
            })));
  return Belt_List.concatMany([
              {
                hd: {
                  TAG: /* Label */6,
                  _0: fun[0]
                },
                tl: compile_expr(fun[2], {
                      hd: /* Stmp */0,
                      tl: stack
                    })
              },
              {
                hd: {
                  TAG: /* Ret */3,
                  _0: Belt_List.length(params)
                },
                tl: /* [] */0
              }
            ]);
}

function compile_prog(expr) {
  var expr$1 = compile(expr);
  var match = check_expr(/* [] */0, expr$1);
  solve(match[1]);
  var fns = Belt_List.flatten(Belt_List.map(preprocess(expr$1), compile_fun));
  return {
          hd: {
            TAG: /* Call */2,
            _0: ident_main,
            _1: 0
          },
          tl: {
            hd: /* Exit */6,
            tl: fns
          }
        };
}

function get_instr_size(instr) {
  if (typeof instr === "number") {
    return 1;
  }
  switch (instr.TAG | 0) {
    case /* Call */2 :
        return 3;
    case /* Cst */0 :
    case /* Var */1 :
    case /* Ret */3 :
    case /* IfZero */4 :
    case /* Goto */5 :
        return 2;
    case /* Label */6 :
        return 0;
    
  }
}

function to_hex(code) {
  return Belt_List.reduce(code, "", (function (sum, item) {
                return sum + Belt_List.reduce(to_little_endian_32(item), "", (function (sum, item) {
                              return sum + ("00" + item.toString(16)).slice(-2);
                            }));
              }));
}

function to_bytecode(instrs) {
  var match = Belt_List.reduce(instrs, [
        /* [] */0,
        0
      ], (function (param, item) {
          var pos = param[1];
          var label_map = param[0];
          if (typeof item === "number" || item.TAG !== /* Label */6) {
            return [
                    label_map,
                    pos + get_instr_size(item) | 0
                  ];
          } else {
            return [
                    {
                      hd: [
                        item._0,
                        pos
                      ],
                      tl: label_map
                    },
                    pos
                  ];
          }
        }));
  var label_map = match[0];
  var compile_instr = function (instr, label_map) {
    if (typeof instr === "number") {
      switch (instr) {
        case /* Add */0 :
            return {
                    hd: 1,
                    tl: /* [] */0
                  };
        case /* Sub */1 :
            return {
                    hd: 11,
                    tl: /* [] */0
                  };
        case /* Mul */2 :
            return {
                    hd: 2,
                    tl: /* [] */0
                  };
        case /* Pop */3 :
            return {
                    hd: 4,
                    tl: /* [] */0
                  };
        case /* Swap */4 :
            return {
                    hd: 5,
                    tl: /* [] */0
                  };
        case /* Le */5 :
            return {
                    hd: 12,
                    tl: /* [] */0
                  };
        case /* Exit */6 :
            return {
                    hd: 10,
                    tl: /* [] */0
                  };
        
      }
    } else {
      switch (instr.TAG | 0) {
        case /* Cst */0 :
            return {
                    hd: 0,
                    tl: {
                      hd: instr._0,
                      tl: /* [] */0
                    }
                  };
        case /* Var */1 :
            return {
                    hd: 3,
                    tl: {
                      hd: instr._0,
                      tl: /* [] */0
                    }
                  };
        case /* Call */2 :
            return {
                    hd: 6,
                    tl: {
                      hd: List.assoc(instr._0, label_map),
                      tl: {
                        hd: instr._1,
                        tl: /* [] */0
                      }
                    }
                  };
        case /* Ret */3 :
            return {
                    hd: 7,
                    tl: {
                      hd: instr._0,
                      tl: /* [] */0
                    }
                  };
        case /* IfZero */4 :
            return {
                    hd: 9,
                    tl: {
                      hd: List.assoc(instr._0, label_map),
                      tl: /* [] */0
                    }
                  };
        case /* Goto */5 :
            return {
                    hd: 8,
                    tl: {
                      hd: List.assoc(instr._0, label_map),
                      tl: /* [] */0
                    }
                  };
        case /* Label */6 :
            return /* [] */0;
        
      }
    }
  };
  return Belt_List.reduce(instrs, /* [] */0, (function (code, instr) {
                var tmp;
                tmp = typeof instr === "number" || instr.TAG !== /* Label */6 ? compile_instr(instr, label_map) : /* [] */0;
                return Belt_List.concatMany([
                            code,
                            tmp
                          ]);
              }));
}

function compile_indexed(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Add */0,
                      tl: /* [] */0
                    }
                  ]);
    case /* Mul */2 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Mul */2,
                      tl: /* [] */0
                    }
                  ]);
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Swap */4,
                      tl: {
                        hd: /* Pop */3,
                        tl: /* [] */0
                      }
                    }
                  ]);
    case /* Fn */5 :
    case /* App */6 :
        throw {
              RE_EXN_ID: "Match_failure",
              _1: [
                "Demo.res",
                699,
                4
              ],
              Error: new Error()
            };
    
  }
}

function print$2(instrs) {
  for(var i = 1 ,i_finish = List.length(instrs); i <= i_finish; ++i){
    var i$1 = List.nth(instrs, i - 1 | 0);
    var instr_text;
    if (typeof i$1 === "number") {
      switch (i$1) {
        case /* Add */0 :
            instr_text = "add";
            break;
        case /* Sub */1 :
            instr_text = "sub";
            break;
        case /* Mul */2 :
            instr_text = "mul";
            break;
        case /* Pop */3 :
            instr_text = "pop";
            break;
        case /* Swap */4 :
            instr_text = "swap";
            break;
        case /* Le */5 :
            instr_text = "le";
            break;
        case /* Exit */6 :
            instr_text = "exit";
            break;
        
      }
    } else {
      switch (i$1.TAG | 0) {
        case /* Cst */0 :
            instr_text = "const " + String(i$1._0);
            break;
        case /* Var */1 :
            instr_text = "var " + String(i$1._0);
            break;
        case /* Call */2 :
            instr_text = "call/" + String(i$1._1) + " " + i$1._0.name;
            break;
        case /* Ret */3 :
            instr_text = "ret " + String(i$1._0);
            break;
        case /* IfZero */4 :
            instr_text = "if_zero " + i$1._0.name;
            break;
        case /* Goto */5 :
            instr_text = "goto " + i$1._0.name;
            break;
        case /* Label */6 :
            instr_text = i$1._0.name + ":";
            break;
        
      }
    }
    console.log(instr_text);
  }
}

var Vm = {
  instr_const: 0,
  instr_add: 1,
  instr_mul: 2,
  instr_var: 3,
  instr_pop: 4,
  instr_swap: 5,
  instr_call: 6,
  instr_ret: 7,
  instr_goto: 8,
  instr_if_zero: 9,
  instr_exit: 10,
  instr_sub: 11,
  instr_le: 12,
  ident_main: ident_main,
  find_local_index: find_local_index$1,
  preprocess: preprocess,
  compile_expr: compile_expr,
  compile_fun: compile_fun,
  compile_prog: compile_prog,
  get_instr_size: get_instr_size,
  to_hex: to_hex,
  to_bytecode: to_bytecode,
  compile_indexed: compile_indexed,
  print: print$2
};

function compile_vm(instrs) {
  var compile_instr = function (instr) {
    if (typeof instr === "number") {
      switch (instr) {
        case /* Add */0 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rbx */2
                      },
                      tl: {
                        hd: {
                          TAG: /* Add */4,
                          _0: /* Rax */1,
                          _1: /* Rbx */2
                        },
                        tl: {
                          hd: {
                            TAG: /* Push */2,
                            _0: /* Rax */1
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  };
        case /* Sub */1 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rbx */2
                    },
                    tl: {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rax */1
                      },
                      tl: {
                        hd: {
                          TAG: /* Sub */5,
                          _0: /* Rax */1,
                          _1: /* Rbx */2
                        },
                        tl: {
                          hd: {
                            TAG: /* Push */2,
                            _0: /* Rax */1
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  };
        case /* Mul */2 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rbx */2
                      },
                      tl: {
                        hd: {
                          TAG: /* Mul */6,
                          _0: /* Rbx */2
                        },
                        tl: {
                          hd: {
                            TAG: /* Push */2,
                            _0: /* Rax */1
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  };
        case /* Pop */3 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: /* [] */0
                  };
        case /* Swap */4 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rbx */2
                      },
                      tl: {
                        hd: {
                          TAG: /* Push */2,
                          _0: /* Rax */1
                        },
                        tl: {
                          hd: {
                            TAG: /* Push */2,
                            _0: /* Rbx */2
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  };
        case /* Le */5 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rbx */2
                    },
                    tl: {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rax */1
                      },
                      tl: {
                        hd: {
                          TAG: /* Cmp */8,
                          _0: /* Rax */1,
                          _1: /* Rbx */2
                        },
                        tl: {
                          hd: {
                            TAG: /* Setna */9,
                            _0: /* Al */0
                          },
                          tl: {
                            hd: {
                              TAG: /* Movzx */1,
                              _0: /* Rbx */2,
                              _1: /* Al */0
                            },
                            tl: {
                              hd: {
                                TAG: /* Push */2,
                                _0: /* Rbx */2
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  };
        case /* Exit */6 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: {
                      hd: /* Ret */0,
                      tl: /* [] */0
                    }
                  };
        
      }
    } else {
      switch (instr.TAG | 0) {
        case /* Cst */0 :
            return {
                    hd: {
                      TAG: /* Mov */0,
                      _0: /* Rax */1,
                      _1: {
                        TAG: /* Constant */0,
                        _0: instr._0
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* Push */2,
                        _0: /* Rax */1
                      },
                      tl: /* [] */0
                    }
                  };
        case /* Var */1 :
            return {
                    hd: {
                      TAG: /* Mov */0,
                      _0: /* Rbx */2,
                      _1: {
                        TAG: /* Constant */0,
                        _0: instr._0
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* Mov */0,
                        _0: /* Rax */1,
                        _1: {
                          TAG: /* RegOffset */3,
                          base: /* Rsp */5,
                          index: /* Rbx */2,
                          scale: 8,
                          disp: 0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* Push */2,
                          _0: /* Rax */1
                        },
                        tl: /* [] */0
                      }
                    }
                  };
        case /* Call */2 :
            return {
                    hd: {
                      TAG: /* Call */12,
                      _0: instr._0
                    },
                    tl: {
                      hd: {
                        TAG: /* Push */2,
                        _0: /* Rax */1
                      },
                      tl: /* [] */0
                    }
                  };
        case /* Ret */3 :
            var n = instr._0;
            if (n !== 0) {
              return {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rax */1
                      },
                      tl: {
                        hd: {
                          TAG: /* Retn */10,
                          _0: (n << 3)
                        },
                        tl: /* [] */0
                      }
                    };
            } else {
              return {
                      hd: {
                        TAG: /* Pop */3,
                        _0: /* Rax */1
                      },
                      tl: {
                        hd: /* Ret */0,
                        tl: /* [] */0
                      }
                    };
            }
        case /* IfZero */4 :
            return {
                    hd: {
                      TAG: /* Pop */3,
                      _0: /* Rax */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Test */7,
                        _0: /* Rax */1,
                        _1: /* Rax */1
                      },
                      tl: {
                        hd: {
                          TAG: /* Je */14,
                          _0: instr._0
                        },
                        tl: /* [] */0
                      }
                    }
                  };
        case /* Goto */5 :
            return {
                    hd: {
                      TAG: /* Goto */13,
                      _0: instr._0
                    },
                    tl: /* [] */0
                  };
        case /* Label */6 :
            return {
                    hd: {
                      TAG: /* Label */11,
                      _0: instr._0
                    },
                    tl: /* [] */0
                  };
        
      }
    }
  };
  var compile_inner = function (instrs) {
    if (!instrs) {
      return /* [] */0;
    }
    var head = instrs.hd;
    if (head === 4) {
      var match = instrs.tl;
      if (match && match.hd === 3) {
        return {
                hd: {
                  TAG: /* Pop */3,
                  _0: /* Rax */1
                },
                tl: {
                  hd: {
                    TAG: /* Pop */3,
                    _0: /* Rbx */2
                  },
                  tl: {
                    hd: {
                      TAG: /* Push */2,
                      _0: /* Rax */1
                    },
                    tl: compile_inner(match.tl)
                  }
                }
              };
      }
      
    }
    return Belt_List.concatMany([
                compile_instr(head),
                compile_inner(instrs.tl)
              ]);
  };
  return compile_inner(instrs);
}

function optimize(instrs) {
  var optimize_inner = function (_instrs) {
    while(true) {
      var instrs = _instrs;
      if (!instrs) {
        return /* [] */0;
      }
      var head = instrs.hd;
      if (typeof head !== "number" && head.TAG === /* Push */2 && head._0 === 1) {
        var match = instrs.tl;
        if (match) {
          var match$1 = match.hd;
          if (typeof match$1 !== "number" && match$1.TAG === /* Pop */3 && match$1._0 === 1) {
            _instrs = match.tl;
            continue ;
          }
          
        }
        
      }
      return {
              hd: head,
              tl: optimize_inner(instrs.tl)
            };
    };
  };
  var _instrs = instrs;
  while(true) {
    var instrs$1 = _instrs;
    var o = optimize_inner(instrs$1);
    if (Belt_List.length(o) === Belt_List.length(instrs$1)) {
      return o;
    }
    _instrs = o;
    continue ;
  };
}

function to_reg_str(reg) {
  switch (reg) {
    case /* Al */0 :
        return "al";
    case /* Rax */1 :
        return "rax";
    case /* Rbx */2 :
        return "rbx";
    case /* Rcx */3 :
        return "rcx";
    case /* Rdx */4 :
        return "rdx";
    case /* Rsp */5 :
        return "rsp";
    
  }
}

function to_mov_arg_str(reg) {
  switch (reg.TAG | 0) {
    case /* Constant */0 :
        return String(reg._0);
    case /* Reg */1 :
        return to_reg_str(reg._0);
    case /* Addr */2 :
        return "[" + String(reg._0) + "]";
    case /* RegOffset */3 :
        return "[" + to_reg_str(reg.base) + "+" + to_reg_str(reg.index) + "*" + String(reg.scale) + "+" + String(reg.disp) + "]";
    
  }
}

function print$3(instrs) {
  var get_label = function (label) {
    return label.name + "_" + String(label.stamp);
  };
  var instr_text = Belt_List.map(instrs, (function (instr) {
          if (typeof instr === "number") {
            return "ret";
          }
          switch (instr.TAG | 0) {
            case /* Mov */0 :
                return "mov " + to_reg_str(instr._0) + ", " + to_mov_arg_str(instr._1);
            case /* Movzx */1 :
                return "movzx " + to_reg_str(instr._0) + ", " + to_reg_str(instr._1);
            case /* Push */2 :
                return "push " + to_reg_str(instr._0);
            case /* Pop */3 :
                return "pop " + to_reg_str(instr._0);
            case /* Add */4 :
                return "add " + to_reg_str(instr._0) + ", " + to_reg_str(instr._1);
            case /* Sub */5 :
                return "sub " + to_reg_str(instr._0) + ", " + to_reg_str(instr._1);
            case /* Mul */6 :
                return "mul " + to_reg_str(instr._0);
            case /* Test */7 :
                return "test " + to_reg_str(instr._0) + ", " + to_reg_str(instr._1);
            case /* Cmp */8 :
                return "cmp " + to_reg_str(instr._0) + ", " + to_reg_str(instr._1);
            case /* Setna */9 :
                return "setna " + to_reg_str(instr._0);
            case /* Retn */10 :
                return "ret " + String(instr._0);
            case /* Label */11 :
                var label = instr._0;
                var props = label.ty === /* Function */1 ? (
                    is_linux ? ".type " + get_label(label) + ",@function\n.global " + get_label(label) + "\n" : ".def " + get_label(label) + ";\n.scl 2;\n.type 32;\n.endef\n"
                  ) : "";
                return props + get_label(label) + ":";
            case /* Call */12 :
                return "call " + get_label(instr._0);
            case /* Goto */13 :
                return "jmp " + get_label(instr._0);
            case /* Je */14 :
                return "je " + get_label(instr._0);
            
          }
        }));
  return Belt_List.reduce(instr_text, ".intel_syntax noprefix\n", (function (res, ins) {
                return res + ins + "\n";
              }));
}

var Native = {
  compile_vm: compile_vm,
  optimize: optimize,
  to_reg_str: to_reg_str,
  to_mov_arg_str: to_mov_arg_str,
  print: print$3
};

var my_expr = {
  TAG: /* Add */2,
  _0: {
    TAG: /* Le */9,
    _0: {
      TAG: /* CstI */0,
      _0: 1
    },
    _1: {
      TAG: /* CstI */0,
      _0: 1
    }
  },
  _1: {
    TAG: /* CstI */0,
    _0: 1
  }
};

var instrs2 = compile_prog(my_expr);

var bytecode = to_hex(to_bytecode(Belt_List.concatMany([
              instrs2,
              {
                hd: /* Exit */6,
                tl: /* [] */0
              }
            ])));

Fs.writeFileSync("bytecode.bin", bytecode, "hex");

var assembly = optimize(compile_vm(instrs2));

Fs.writeFileSync("machine_code.s", print$3(assembly), "utf8");

export {
  is_linux ,
  findIndex ,
  to_little_endian_32 ,
  Ast ,
  Resolve ,
  Nameless ,
  Indexed ,
  Vm ,
  Native ,
  my_expr ,
  instrs2 ,
  bytecode ,
  assembly ,
}
/* is_linux Not a pure module */
