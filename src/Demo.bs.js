// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";

function findIndex(list, item) {
  var _list = list;
  var _index = 0;
  while(true) {
    var index = _index;
    var list$1 = _list;
    if (list$1) {
      if (list$1.hd === item) {
        return index;
      }
      _index = index + 1 | 0;
      _list = list$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function $$eval(expr) {
  var eval_inner = function (_expr, _env) {
    while(true) {
      var env = _env;
      var expr = _expr;
      switch (expr.TAG | 0) {
        case /* Cst */0 :
            return expr._0;
        case /* Add */1 :
            return eval_inner(expr._0, env) + eval_inner(expr._1, env) | 0;
        case /* Mul */2 :
            return Math.imul(eval_inner(expr._0, env), eval_inner(expr._1, env));
        case /* Var */3 :
            return List.assoc(expr._0, env);
        case /* Let */4 :
            _env = {
              hd: [
                expr._0,
                eval_inner(expr._1, env)
              ],
              tl: env
            };
            _expr = expr._2;
            continue ;
        case /* Fn */5 :
        case /* App */6 :
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Demo.res",
                    31,
                    13
                  ],
                  Error: new Error()
                };
        
      }
    };
  };
  return eval_inner(expr, /* [] */0);
}

var Ast = {
  $$eval: $$eval
};

function compile(expr) {
  var compile_inner = function (expr, cenv) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  TAG: /* Cst */0,
                  _0: expr._0
                };
      case /* Add */1 :
          return {
                  TAG: /* Add */1,
                  _0: compile_inner(expr._0, cenv),
                  _1: compile_inner(expr._1, cenv)
                };
      case /* Mul */2 :
          return {
                  TAG: /* Mul */2,
                  _0: compile_inner(expr._0, cenv),
                  _1: compile_inner(expr._1, cenv)
                };
      case /* Var */3 :
          return {
                  TAG: /* Var */3,
                  _0: findIndex(cenv, expr._0)
                };
      case /* Let */4 :
          return {
                  TAG: /* Let */4,
                  _0: compile_inner(expr._1, cenv),
                  _1: compile_inner(expr._2, {
                        hd: expr._0,
                        tl: cenv
                      })
                };
      case /* Fn */5 :
      case /* App */6 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Demo.res",
                  55,
                  13
                ],
                Error: new Error()
              };
      
    }
  };
  return compile_inner(expr, /* [] */0);
}

var Nameless = {
  compile: compile
};

function find_local_index(env, local_index) {
  var _env = env;
  var _local_index = local_index;
  var _stack_index = 0;
  while(true) {
    var stack_index = _stack_index;
    var local_index$1 = _local_index;
    var env$1 = _env;
    if (env$1) {
      if (local_index$1 !== 0) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var head = env$1.hd;
      if (head === /* Slocal */0) {
        return stack_index;
      }
      _stack_index = stack_index + 1 | 0;
      _local_index = head === /* Slocal */0 ? local_index$1 - 1 | 0 : local_index$1;
      _env = env$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function compile$1(expr) {
  var go = function (expr, env) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  TAG: /* Cst */0,
                  _0: expr._0
                };
      case /* Add */1 :
          return {
                  TAG: /* Add */1,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Stmp */1,
                        tl: env
                      })
                };
      case /* Mul */2 :
          return {
                  TAG: /* Mul */2,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Stmp */1,
                        tl: env
                      })
                };
      case /* Var */3 :
          return {
                  TAG: /* Var */3,
                  _0: find_local_index(env, expr._0)
                };
      case /* Let */4 :
          return {
                  TAG: /* Let */4,
                  _0: go(expr._0, env),
                  _1: go(expr._1, {
                        hd: /* Slocal */0,
                        tl: env
                      })
                };
      
    }
  };
  return go(expr, /* [] */0);
}

var Indexed = {
  find_local_index: find_local_index,
  compile: compile$1
};

function $$eval$1(_instrs, _stk) {
  while(true) {
    var stk = _stk;
    var instrs = _instrs;
    if (instrs) {
      var i = instrs.hd;
      if (typeof i === "number") {
        switch (i) {
          case /* Add */0 :
              if (stk) {
                var match = stk.tl;
                if (match) {
                  _stk = {
                    hd: stk.hd + match.hd | 0,
                    tl: match.tl
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          case /* Mul */1 :
              if (stk) {
                var match$1 = stk.tl;
                if (match$1) {
                  _stk = {
                    hd: Math.imul(stk.hd, match$1.hd),
                    tl: match$1.tl
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          case /* Pop */2 :
              if (stk) {
                _stk = stk.tl;
                _instrs = instrs.tl;
                continue ;
              }
              break;
          case /* Swap */3 :
              if (stk) {
                var match$2 = stk.tl;
                if (match$2) {
                  _stk = {
                    hd: match$2.hd,
                    tl: {
                      hd: stk.hd,
                      tl: match$2.tl
                    }
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          
        }
      } else {
        if (i.TAG === /* Cst */0) {
          _stk = {
            hd: i._0,
            tl: stk
          };
          _instrs = instrs.tl;
          continue ;
        }
        _stk = {
          hd: List.nth(stk, i._0),
          tl: stk
        };
        _instrs = instrs.tl;
        continue ;
      }
    } else if (stk && !stk.tl) {
      return stk.hd;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Demo.res",
            114,
            11
          ],
          Error: new Error()
        };
  };
}

function find_local_index$1(env, name) {
  var _env = env;
  var _stack_index = 0;
  while(true) {
    var stack_index = _stack_index;
    var env$1 = _env;
    if (env$1) {
      var head = env$1.hd;
      if (head) {
        if (head._0 === name) {
          return stack_index;
        }
        _stack_index = stack_index + 1 | 0;
        _env = env$1.tl;
        continue ;
      }
      _stack_index = stack_index + 1 | 0;
      _env = env$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function compile_ast(expr) {
  var compile_inner = function (expr, env) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  hd: {
                    TAG: /* Cst */0,
                    _0: expr._0
                  },
                  tl: /* [] */0
                };
      case /* Add */1 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }),
                      {
                        hd: /* Add */0,
                        tl: /* [] */0
                      }
                    ]);
      case /* Mul */2 :
          return Belt_List.concatMany([
                      compile_inner(expr._0, env),
                      compile_inner(expr._1, {
                            hd: /* Stmp */0,
                            tl: env
                          }),
                      {
                        hd: /* Mul */1,
                        tl: /* [] */0
                      }
                    ]);
      case /* Var */3 :
          return {
                  hd: {
                    TAG: /* Var */1,
                    _0: find_local_index$1(env, expr._0)
                  },
                  tl: /* [] */0
                };
      case /* Let */4 :
          return Belt_List.concatMany([
                      compile_inner(expr._1, env),
                      compile_inner(expr._2, {
                            hd: /* Slocal */{
                              _0: expr._0
                            },
                            tl: env
                          }),
                      {
                        hd: /* Swap */3,
                        tl: {
                          hd: /* Pop */2,
                          tl: /* [] */0
                        }
                      }
                    ]);
      case /* Fn */5 :
      case /* App */6 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Demo.res",
                  143,
                  13
                ],
                Error: new Error()
              };
      
    }
  };
  return compile_inner(expr, /* [] */0);
}

function compile_nameless(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return Belt_List.concatMany([
                    compile_nameless(expr._0),
                    compile_nameless(expr._1),
                    {
                      hd: /* Add */0,
                      tl: /* [] */0
                    }
                  ]);
    case /* Mul */2 :
        return Belt_List.concatMany([
                    compile_nameless(expr._0),
                    compile_nameless(expr._1),
                    {
                      hd: /* Mul */1,
                      tl: /* [] */0
                    }
                  ]);
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return Belt_List.concatMany([
                    compile_nameless(expr._0),
                    compile_nameless(expr._1),
                    {
                      hd: /* Swap */3,
                      tl: {
                        hd: /* Pop */2,
                        tl: /* [] */0
                      }
                    }
                  ]);
    
  }
}

function compile_indexed(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Add */0,
                      tl: /* [] */0
                    }
                  ]);
    case /* Mul */2 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Mul */1,
                      tl: /* [] */0
                    }
                  ]);
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return Belt_List.concatMany([
                    compile_indexed(expr._0),
                    compile_indexed(expr._1),
                    {
                      hd: /* Swap */3,
                      tl: {
                        hd: /* Pop */2,
                        tl: /* [] */0
                      }
                    }
                  ]);
    
  }
}

function print(instrs) {
  for(var i = 1 ,i_finish = List.length(instrs); i <= i_finish; ++i){
    var i$1 = List.nth(instrs, i - 1 | 0);
    var instr_text;
    if (typeof i$1 === "number") {
      switch (i$1) {
        case /* Add */0 :
            instr_text = "add";
            break;
        case /* Mul */1 :
            instr_text = "mul";
            break;
        case /* Pop */2 :
            instr_text = "pop";
            break;
        case /* Swap */3 :
            instr_text = "swap";
            break;
        
      }
    } else {
      instr_text = i$1.TAG === /* Cst */0 ? "const " + String(i$1._0) : "var " + String(i$1._0);
    }
    console.log(instr_text);
  }
}

var Vm = {
  $$eval: $$eval$1,
  find_local_index: find_local_index$1,
  compile_ast: compile_ast,
  compile_nameless: compile_nameless,
  compile_indexed: compile_indexed,
  print: print
};

var my_expr = {
  TAG: /* Add */1,
  _0: {
    TAG: /* Add */1,
    _0: {
      TAG: /* Cst */0,
      _0: 1
    },
    _1: {
      TAG: /* Let */4,
      _0: "x",
      _1: {
        TAG: /* Cst */0,
        _0: 2
      },
      _2: {
        TAG: /* Add */1,
        _0: {
          TAG: /* Var */3,
          _0: "x"
        },
        _1: {
          TAG: /* Var */3,
          _0: "x"
        }
      }
    }
  },
  _1: {
    TAG: /* Cst */0,
    _0: 3
  }
};

var my_nameless = compile(my_expr);

var my_indexed = compile$1(my_nameless);

var instrs = compile_indexed(my_indexed);

var instrs2 = compile_ast(my_expr);

console.log("==> multi-level ir:");

print(instrs);

console.log("==> single pass:");

print(instrs2);

console.log($$eval(my_expr));

console.log($$eval$1(instrs, /* [] */0));

console.log($$eval$1(instrs2, /* [] */0));

export {
  findIndex ,
  Ast ,
  Nameless ,
  Indexed ,
  Vm ,
  my_expr ,
  my_nameless ,
  my_indexed ,
  instrs ,
  instrs2 ,
}
/* my_nameless Not a pure module */
